import numpy as np
import scipy as sp
import os
import random

def generate_band_mtx_matrix(N: int, b: int, foldername: str = None, filename: str = None):
    """
    Generate a sparse banded matrix of size N x N with bandwidth b.
    Store it to the disc in .mtx format. 
    The values of the matrix are all 1.
    """

    # .mtx format requires edge list. Generate the edge list for band matrix
    edges = []
    for i in range(N):
        for j in range(max(0, i-b), min(N, i+b+1)):
            edges.append((i+1, j+1, 1))

    # .mtx header:
    mtx_header = f'%%MatrixMarket matrix coordinate real general\n% Generated by generate_band_mtx_matrix\n{N} {N} {len(edges)}'

    # Save the .mtx file
    if foldername is None:
        foldername = 'matrices/band_matrices_4_times'
        
    # check if folder exists, otherwise create it
    if not os.path.exists(foldername):
        os.makedirs(foldername)

    if filename is None:
        filename = f'band_mtx_{N}_{b}.mtx'

    with open(os.path.join(foldername, filename), 'w') as f:
        f.write(mtx_header + '\n')
        for edge in edges:
            f.write(' '.join(str(x) for x in edge) + '\n')
            

import os
import random
import math
from collections import defaultdict
import numpy as np


def generate_band_mtx_matrix_2_4_sparse(N: int, b: int, foldername: str = None, filename: str = None):
    """
    Generate a sparse banded matrix of size N x N with bandwidth b, ensuring 2:4 sparsity within 16x16 blocks inside the band.
    Store it to the disc in .mtx format.
    The values of the matrix are all 1.
    """
    block_size = 16
    edges = []
    
    for block_row in range(0, N, block_size):
        for block_col in range(max(0, block_row - b), min(N, block_row + b + block_size), block_size):
            # Generate edges for this 16x16 block
            block_edges = []
            for i in range(block_row, min(block_row + block_size, N)):
                for j in range(block_col, min(block_col + block_size, N), 4):
                    if abs(i - j) <= b:  # Check if within band
                        # Ensure 2:4 sparsity for each group of 4
                        group = [(i+1, j+k+1, 1) for k in range(4) if j+k < min(block_col + block_size, N)]
                        if len(group) > 2:
                            group = random.sample(group, 2)
                        block_edges.extend(group)
            
            edges.extend(block_edges)

    # MTX header
    mtx_header = f'%%MatrixMarket matrix coordinate real general\n% Generated by generate_band_mtx_matrix_2_4_sparse\n{N} {N} {len(edges)}'

    # Save the .mtx file
    if foldername is None:
        foldername = 'matrices/band_matrices_2_4_sparse'
    # Check if folder exists, otherwise create it
    if not os.path.exists(foldername):
        os.makedirs(foldername)
    if filename is None:
        filename = f'band_mtx_2_4_sparse_{N}_{b}.mtx'

    with open(os.path.join(foldername, filename), 'w') as f:
        f.write(mtx_header + '\n')
        for edge in edges:
            f.write(' '.join(str(x) for x in edge) + '\n')

    print(f"Generated 2:4 sparse banded matrix: {filename}")
    print(f"Dimensions: {N}x{N}")
    print(f"Bandwidth: {b}")
    print(f"Number of non-zero elements: {len(edges)}")
    print(f"Density: {len(edges)/(N*N):.6f}")

def generate_2_4_sparse_matrix(N: int, density: float, foldername: str = None, filename: str = None):
    """
    Generate a 2:4 sparse matrix of size N x N with the given density.
    Store it to the disc in .mtx format.
    The values of the matrix are random integers between 1 and 32.
    """
    # Calculate the number of non-zero elements
    nnz = int(N * N * density)
    # Create a list of all possible positions
    positions = [(i, j) for i in range(N) for j in range(N)]
    # Randomly select positions for non-zero elements
    non_zero_positions = random.sample(positions, nnz)
    # Create the edge list, ensuring 2:4 sparsity
    # --- Improved Version: Pre-group nonzero positions by row ---
    row_edges_dict = defaultdict(list)
    for r, c in non_zero_positions:
        row_edges_dict[r].append(c)
    
    # edges = []
    # for i in range(N):
    #     row_edges = row_edges_dict.get(i, [])
    #     # Process 4-column blocks within row i
    #     for j in range(0, N, 4):
    #         # Get all column indices within the current 4-column block
    #         block = [c for c in row_edges if j <= c < j + 4]
    #         if len(block) > 2:
    #             block = random.sample(block, 2)
    #         # Append each edge with a random value between 1 and 32
    #         for c in block:
    #             edges.append((i, c, random.randint(1, 32)))
    # --- Alternative Version: Using NumPy for vectorized filtering ---
    # Uncomment the following block if you prefer the NumPy approach.
    non_zero_positions_np = np.array(non_zero_positions)
    edges = []
    for i in range(N):
        mask_row = non_zero_positions_np[:, 0] == i
        row_edges = non_zero_positions_np[mask_row][:, 1]
        for j in range(0, N, 4):
            mask_block = (row_edges >= j) & (row_edges < j + 4)
            block = row_edges[mask_block]
            if block.size > 2:
                block = np.random.choice(block, 2, replace=False)
            for c in block:
                edges.append((i, int(c), random.randint(1, 32)))

    # Sort edges for consistency (by row, then column)
    edges.sort()

    # MTX header
    mtx_header = f'%%MatrixMarket matrix coordinate real general\n% Generated by generate_2_4_sparse_matrix\n{N} {N} {len(edges)}'

    # Save the .mtx file
    if foldername is None:
        foldername = 'matrices/2_4_sparse_matrices'
    # Check if folder exists, otherwise create it
    if not os.path.exists(foldername):
        os.makedirs(foldername)
    if filename is None:
        filename = f'2_4_sparse_mtx_{N}_{density:.4f}.mtx'

    with open(os.path.join(foldername, filename), 'w') as f:
        f.write(mtx_header + '\n')
        for edge in edges:
            f.write(f'{edge[0]+1} {edge[1]+1} {edge[2]}\n')

    print(f"Generated 2:4 sparse matrix: {filename}")
    print(f"Dimensions: {N}x{N}")
    print(f"Number of non-zero elements: {len(edges)}")
    print(f"Actual density: {len(edges)/(N*N):.4f}")
import sys

def main():
    n = len(sys.argv)
    if n < 5:
        N_min = 16_384
        N_max = 16_384
        b_min = 32
        b_max = 32
        # N_min = 16384
        # N_max = 16384
        # b_min = 64
        # b_max = 16385
    else:
        N_min = sys.argv[1]
        N_max = sys.argv[2]
        b_min = sys.argv[3]
        b_max = sys.argv[4]
        
    generate_2_4_sparse_matrix(4096, 0.1)

    # N = N_min
    # while (N <= N_max):
    #     b = b_min
    #     while (b <= b_max):
    #         generate_band_mtx_matrix_2_4_sparse(N, b)
    #         b *= 4
    #     N *= 2

if __name__ == '__main__':
    main()
